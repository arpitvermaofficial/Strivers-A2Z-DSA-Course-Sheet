//{ Driver Code Starts
// Initial Template for C++

#include <bits/stdc++.h>
using namespace std;


// } Driver Code Ends
// User function Template for C++
class DisjointSet {

public:
    vector<int> rank, parent, size;
    DisjointSet(int n) {
        rank.resize(n + 1, 0);
        parent.resize(n + 1);
        size.resize(n + 1);
        for (int i = 0; i <= n; i++) {
            parent[i] = i;
            size[i] = 1;
        }
    }

    int findUPar(int node) {
        if (node == parent[node])
            return node;
        return parent[node] = findUPar(parent[node]);
    }

    void unionByRank(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (rank[ulp_u] < rank[ulp_v]) {
            parent[ulp_u] = ulp_v;
        }
        else if (rank[ulp_v] < rank[ulp_u]) {
            parent[ulp_v] = ulp_u;
        }
        else {
            parent[ulp_v] = ulp_u;
            rank[ulp_u]++;
        }
    }

    void unionBySize(int u, int v) {
        int ulp_u = findUPar(u);
        int ulp_v = findUPar(v);
        if (ulp_u == ulp_v) return;
        if (size[ulp_u] < size[ulp_v]) {
            parent[ulp_u] = ulp_v;
            size[ulp_v] += size[ulp_u];
        }
        else {
            parent[ulp_v] = ulp_u;
            size[ulp_u] += size[ulp_v];
        }
    }
};
class Solution {
  public:
    int MaxConnection(vector<vector<int>>& grid) {
        // code here
        int n=grid.size();
       DisjointSet ds(n*n);
        int r[]={-1,0,1,0};
               int c[]={0,1,0,-1};
       for(int row=0;row<n;row++){
           for(int col=0;col<n;col++){
               if(grid[row][col]==0){
                   continue;
               }
               for(int i=0;i<4;i++){
                   int nr=row+r[i];
                   int nc=col+c[i];
                   if(nr>=0&&nc>=0&&nr<n&&nc<n&& grid[nr][nc] == 1){
                       int nodeno=row*n+col;
                       int adjnode=nr*n+nc;
                       ds.unionBySize(nodeno,adjnode);
                   }
               }
              
           }
       }
       int mx=0;
       for(int row=0;row<n;row++){
           for(int col=0;col<n;col++){
               set<int>components;
               if(grid[row][col]==1)continue;
               for(int i=0;i<4;i++){
                   int nr=row+r[i];
                   int nc=col+c[i];
                   if(nr>=0&&nc>=0&&nr<n&&nc<n&&grid[nr][nc]==1){
                       components.insert(ds.findUPar(nr*n+nc));
                   }
                   
               }
               int sizetotal=0;
               for(auto it:components){
                   sizetotal+=ds.size[it];
               }
               mx=max(mx,sizetotal+1);
           }
       }
       for(int cellno=0;cellno<n*n;cellno++){
           mx=max(mx,ds.size[ds.findUPar(cellno)]);
       }
       return mx;
       
       
    }
};


//{ Driver Code Starts.
int main() {

    int t;
    cin >> t;
    while (t--) {
        int n;
        cin >> n;
        vector<vector<int>> grid(n, vector<int>(n));

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                cin >> grid[i][j];
            }
        }

        Solution obj;
        cout<<obj.MaxConnection(grid)<<"\n";
    }
}

// } Driver Code Ends
